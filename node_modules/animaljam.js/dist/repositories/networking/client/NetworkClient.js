import { EventEmitter } from 'node:events';
import { createConnection } from 'node:net';
import { connect as tlsConnect } from 'node:tls';
import { createConnectRequest, handleSocketResponse } from '../../../utils/proxy.js';
import { DelimiterTransform } from '../transform/index.js';
export class NetworkClient extends EventEmitter {
    options;
    socket = null;
    constructor(options) {
        super();
        this.options = options;
    }
    async connect() {
        if (this.options.proxy)
            await this.createProxyConnection();
        else
            await this.createConnection();
        this.socket
            .pipe(new DelimiterTransform(0x00))
            .on('data', data => this.emit('received', data))
            .on('close', () => this.emit('close'))
            .on('error', err => this.emit('error', err));
    }
    async write(message) {
        return new Promise((resolve, reject) => {
            const cleanup = () => {
                this.socket.off('error', onError);
                this.socket.off('close', onClose);
            };
            const onError = (err) => {
                cleanup();
                reject(err);
            };
            const onClose = () => {
                cleanup();
                reject(new Error('Socket closed before the message could be sent'));
            };
            this.socket.once('error', onError);
            this.socket.once('close', onClose);
            const writable = this.socket.write(message) && this.socket.write('\x00');
            if (writable) {
                cleanup();
                resolve(message.length);
            }
            else {
                this.socket.once('drain', () => {
                    cleanup();
                    resolve(message.length);
                });
            }
        });
    }
    async createProxyConnection() {
        return new Promise((resolve, reject) => {
            const proxySocket = createConnection({
                host: this.options.proxy?.host,
                port: this.options.proxy?.port,
            });
            const cleanUp = () => {
                proxySocket.removeAllListeners();
                this.socket?.removeAllListeners();
            };
            proxySocket.once('connect', () => {
                proxySocket.write(createConnectRequest(this.options.host, this.options.port, true));
            });
            proxySocket.once('data', (data) => {
                try {
                    const { statusCode } = handleSocketResponse(data);
                    if (statusCode === 200) {
                        if (this.options.domain === 'mobile') {
                            this.socket = proxySocket;
                            cleanUp();
                            resolve();
                        }
                        else {
                            this.socket = tlsConnect({
                                socket: proxySocket,
                                host: this.options.host,
                                port: this.options.port,
                                rejectUnauthorized: false,
                            });
                            const onTlsConnect = () => {
                                cleanUp();
                                resolve();
                            };
                            this.socket.once('secureConnect', onTlsConnect);
                            this.socket.once('error', (err) => {
                                cleanUp();
                                reject(err);
                            });
                        }
                    }
                    else {
                        cleanUp();
                        reject(new Error(`Proxy connection failed with status code ${statusCode}`));
                    }
                }
                catch (err) {
                    cleanUp();
                    reject(err);
                }
            });
            proxySocket.once('error', (err) => {
                cleanUp();
                reject(err);
            });
            proxySocket.once('close', () => {
                cleanUp();
                reject(new Error('Proxy socket closed unexpectedly'));
            });
        });
    }
    async createConnection() {
        const connectionOptions = {
            host: this.options.host,
            port: this.options.port,
        };
        this.socket =
            this.options.domain === 'mobile'
                ? createConnection(connectionOptions)
                : tlsConnect({
                    ...connectionOptions,
                    rejectUnauthorized: false,
                });
        return new Promise((resolve, reject) => {
            const onConnect = () => {
                this.socket.removeListener('error', reject);
                resolve();
            };
            const onError = (err) => {
                this.socket.removeListener('secureConnect', onConnect);
                this.socket.removeListener('connect', onConnect);
                reject(err);
            };
            this.socket.once('secureConnect', onConnect);
            this.socket.once('connect', onConnect);
            this.socket.once('error', onError);
        });
    }
    async close() {
        return new Promise((resolve, reject) => {
            this.socket.end();
            this.socket.once('close', () => resolve());
            this.socket.once('error', reject);
        });
    }
}
